\documentclass[]{article}
\usepackage[utf8]{inputenc}
\usepackage[sumlimits]{amsmath}
\usepackage{pgfplots}
\pgfplotsset{compat=1.16}
\newcounter{isum}
\pgfplotsset{summand/.initial=max}
\usepackage{amssymb}
\usepackage{color,array,graphics}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[shortlabels]{enumitem}
\usepackage[english]{babel}
\usepackage{wrapfig}
\usepackage{tikz}
\usepackage{tasks}
\usepackage{framed}
\usepackage{comment}
\usepackage{trfsigns}
\usepackage{tabto} 
\usepackage{tabularx}
\usepackage{algorithm}
\usepackage{algpseudocode}

\setlength{\textheight}{8.5in}
\setlength{\textwidth}{6.5in}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\voffset0.0in

\def\OR{\vee}
\def\AND{\wedge}
\def\imp{\rightarrow}
\def\math#1{$#1$}
\def\mand#1{$$#1$$}
\def\mld#1{\begin{equation}
#1
\end{equation}}
\def\eqar#1{\begin{eqnarray}
#1
\end{eqnarray}}
\def\eqan#1{\begin{eqnarray*}
#1
\end{eqnarray*}}
\def\cl#1{{\cal #1}}

\DeclareSymbolFont{AMSb}{U}{msb}{m}{n}
\DeclareMathSymbol{\N}{\mathbin}{AMSb}{"4E}
\DeclareMathSymbol{\Z}{\mathbin}{AMSb}{"5A}
\DeclareMathSymbol{\R}{\mathbin}{AMSb}{"52}
\DeclareMathSymbol{\Q}{\mathbin}{AMSb}{"51}
\DeclareMathSymbol{\I}{\mathbin}{AMSb}{"49}
\DeclareMathSymbol{\C}{\mathbin}{AMSb}{"43}

\begin{document}


% Vertex Cover, Set Cover, Independent Set, SAT and 3-SAT, Hamiltonian Cycle and Path, TSP, 3-Coloring, Subset Sum, or Knapsack

\section{Greedy Algorithms}
\subsection{Exchange Argument}
After describing your algorithm, the 3 main steps for a greedy exchange argument proof are as follows:
\begin{enumerate}
    \item Label your algorithm’s solution, and a general solution. For example, let A = {a1, a2,...,ak} be the solution generated by your algorithm, and let O = {o1, o2,...,om} be an arbitrary (or optimal) feasible solution.
    \item Compare greedy with other solution. Assume that your arbitrary/optimal solution is not the same as your greedy solution (since otherwise, you are done). Typically, you can isolate a simple example of this difference, such as one of the following:
    \begin{itemize}
        \item there is an element of O that is not in A and an element of A that is not in O, or
        \item there are 2 consecutive elements in O in a different order than they are in A (i.e. there is an inversion).
    \end{itemize}
    \item Exchange. Swap the elements in question in O (either swap one element out and another in for the first case, or swap the order of the elements in the second case), and argue that you have a solution that is no worse than before. Then argue that if you continue swapping, you can eliminate all differences between O and A in a polynomial number of steps without worsening the quality of the solution. Thus, the greedy solution produced is just as good as any optimal (or arbitrary) solution, and hence is optimal itself.
\end{enumerate}
Example:\\
A small business-say, a photocopying service with a single large
machine-faces the following scheduling problem. Each morning they
get a set of jobs from customers. They want to do the jobs on their
single machine in an order that keeps their customers happiest.
Customer $i$'s job will take $t_{i}$ time to complete. Given a schedule (i.e.,
an ordering of the jobs), let $C_i$ denote the finishing time of job $i$. For
example, if job $j$ is the first to be done, we would have $C_j$ = $t_j$; and if
job $j$ is done right after job $i$, we would have $C_j$ = $C_i$ + $t_j$. Each
customer $i$ also has a given weight $w_i$ that represents his or her importance to the business. The happiness of customer $i$ is expected to be dependent on the finishing time of $i$'s job. So the company decides that they want to order the jobs to minimize the weighted sum of the completion times, $\sum_{i=1}^{n}w_iC_i$.\\

Design an efficient algorithm to solve this problem. That is, you are
given a set of $n$ jobs with a processing time $t_i$ and a weight $w_i$
for each job. You want to order the jobs so as to minimize the weighted sum of
the completion times, $\sum_{i=1}^{n}w_iC_i$.\\

Example. Suppose there are two jobs: the first takes time $t_1$ = 1 and
has weight $w_1$ = 10, while the second job takes time $t_2$ = 3 and has
weight $w_2$ = 2. Then doing job 1 first would yield a weighted
completion time of 10 · 1 + 2 · 4 = 18, while doing the second job first
would yield the larger weighted completion time of 10 · 4 + 2 · 3 = 46.\\
\centerline{\noindent\rule{12cm}{0.4pt}}
\clearpage
Algorithm/Solution: Order the jobs by sorting them in descending order (highest to lowest) using $\frac{w}{t}$.\\\\
\textbf{Proof by exchange argument:}
\begin{enumerate}
    \item Assume that we have an optimal solution, $OPT_1$, as well as a solution from our algorithm: $GDY$.
    \item If the current $OPT_1$ is equivalent to $GDY$, then we can stop and the assumption is true. Otherwise, we continue the exchange argument.
    \begin{itemize}
        \item If we take an arbitrary element $i$ in $OPT_1$ and the element next to $i$, which we can define as $j$. All of the elements below $i$ will be a set of elements called $b$ (for below), and all the set of elements above $j$ will be called $a$ (for above). 
        \item $OPT_1 = b + w_i * (\sum_{n=1}^{i}t_i) + w_j * (\sum_{n=1}^{j}t_j) + a$
        \item We can define inversion as a pair of jobs $i, j$ for which i comes before j in the alternate solution and j comes before i in the greedy solution. There must exist an adjacent pair i, j.
        \item Using the exchange argument, we can find another answer ($ANS$) as our next solution by removing an inversion by exchanging adjacent elements i and j. This will result in:
        \item $ANS = b + w_j * ((\sum_{n=1}^{i}t_i) - w_i) + w_j * ((\sum_{n=1}^{j}t_j) - w_j) + a$
        \item Then we can compare the $ANS$ with the previous $OPT_1$. $ANS - OPT_1 : $\\
        \begin{equation}
        \begin{align}
        b + w_i * (\sum_{n=1}^{i}t_i) + w_j * (\sum_{n=1}^{j}t_j) + a &- (b + w_j * ((\sum_{n=1}^{j}t_j) - t_i) + w_i * ((\sum_{n=1}^{i}t_i) + t_j) + a)\\
        w_i * (\sum_{n=1}^{i}t_i) + w_j * (\sum_{n=1}^{j}t_j) &- w_j * ((\sum_{n=1}^{j}t_j) - t_i) - w_i * ((\sum_{n=1}^{i}t_i) + t_j)\\
        w_i * (\sum_{n=1}^{i}t_i) + w_j * (\sum_{n=1}^{j}t_j) &- w_j * (\sum_{n=1}^{j}t_j) + w_j * t_i - w_i * (\sum_{n=1}^{i}t_i) - w_i * t_j\\
        w_j * t_i &- w_i * t_j\\
        \end{align}
        \end{equation}
        \item If we take $ANS - OPT_1 : w_j * t_i - w_i * t_j = 0 \rightarrow \frac{w_i}{t_i} = \frac{w_j}{t_j} \rightarrow \frac{w_j}{t_j} - \frac{w_i}{t_i} = 0$. There are multiple cases:
        \begin{enumerate}
            \item $\frac{w_j}{t_j} - \frac{w_i}{t_i} <= 0$, $ANS$ can either be optimal, which we can continue with the inversion. Or that it will lead to the greedy solution, which is the decreasing order of $\frac{w_i}{t_i}$
            \item $\frac{w_j}{t_j} - \frac{w_i}{t_i} > 0$, this would be a contradiction, since this claims that the $ANS$ is more optimal than the optimal solution. This claim cannot be true since you cannot get better than optimal. 
        \end{enumerate}
        $\therefore$ if we reach the greedy solution, then our algorithm is correct $\blacksquare$
    \end{itemize}
\end{enumerate}
\clearpage
\subsection{MST}
Properties of MST:
\begin{itemize}
    \item \textbf{Cut property}: For any cut C of the graph, if the weight of an edge E in the cut-set of C is strictly smaller than the weights of all other edges of the cut-set of C, then the edge belongs to all of the MSTs of the graph G.
    \item \textbf{Cycle property}: For any cycle C in the graph, if the weight of an edge E of C is larger than the individual weights of all other edges of C, then the edge cannot belong in any MST.
    \item \textbf{Uniqueness}: If each edge has a distinct weight, there will only be one unique MST.
    \item \textbf{Multiplicity}: If G(V, E) is a graph then every spanning tree of graph G consists of (V - 1) edges, where V is the number of vertices in the graph and E is the number of edges in the graph. So, (E - V + 1) edges are not a part of the spanning tree. There may be several minimum spanning trees of the same weight. If all the edge weights of a graph are the same, then every spanning tree of that graph is minimum.
    \item \textbf{Min Cost Edge}: If the min-cost edge E of the graph is unique, then this edge is in all MSTs.
\end{itemize}
Example:\\
Let us say that a graph G = (V, E) is a near-tree if it is connected and has at most n + 8 edges, where n = $|$V$|$. Give an algorithm with running time O(n) that takes a near-tree G with costs on its edges, and returns a minimum spanning tree of G. You may assume that all the edge costs are distinct.
\centerline{\noindent\rule{12cm}{0.4pt}}

\textbf{Algorithm:}
\begin{itemize}
    \item Run BFS on G, for every iteration of G we will represent the graph as G' (at every BFS run)
    \begin{itemize}
        \item if we find a cycle with BFS on G' (this means that during BFS, the algorithm will detect when it tries to add a node that is already visited, but not the one it came from), go through the cycle, find the largest edge and remove that edge
        \item Otherwise, we return the graph G' as the MST of G
    \end{itemize}
    \item Repeat the same above algorithm above 8 more times (total with 9 times), if there are no cycles remaining return the graph G' as the MST of G
    \item This algorithm will be linear since BFS takes O(V+E)
\end{itemize}

\textbf{Argument for algorithm:}
\begin{itemize}
    \item G is connected, and if we remove an edge for G' and it is still connected then every other G' is connected. 
    \item When removing edges from G to form G' or the old G' to the new G' Since we are removing an edge from a cycle, the graph is still connected.
    \item For a graph to be a tree, it must have n-1 edges, this graph has at most n + 8 edges, so the algorithm must run at most 9 times to remove all the cycles in the graph to make it a tree. Since we are removing the largest edge from a cycle it will find a MST.
\end{itemize}
\clearpage
\section{Dynamic Programming}
\begin{itemize}
    \item \textbf{Define your subproblem}: This is where you define what a given index of your array(or table) represents.
    \item \textbf{Define your recurrence}: This is where you define how to find a specific value of your subproblems based on smaller subproblems.
    \item \textbf{Algorithm}: This has a few parts. First, define the size and default values of your array/table. Then, set the base case values. Then, iterate through, and use the recurrence to set values. Then, give the return value (which may be a single index of your array, or may involve iterating through the array).
    \item \textbf{Correctness}: doesn't need to be a formal proof (it shouldn't be), but give a general description of what the cases are for the recurrence, and why they model the problem.
    \item \textbf{Running time}: again, doesn't need to be long or formal, but give a brief description of why your algorithm meets the specified running time (or state its running time, if one wasn't given).
\end{itemize}\\
Examples:

\begin{enumerate}
    \item Given sets of values $l_1$, $l_2$, . . . , $l_n$ and $h_1$, $h_2$, . . . , $h_n$, find a plan of maximum value. Example. Suppose n = 4, and the values of $l_i$ and $h_i$ are given by the following table. Then the plan of maximum value would be to choose “none” in week 1, a high-stress job in week 2, and low-stress jobs in weeks 3 and 4. The value of this plan would be 0 + 50 + 10 + 10 = 70.\\
\textbf{Subproblem:} OPT[i] = the maximum dollars you get for working to i week(s)\\
\textbf{Recurrence:} 
\begin{equation}
    OPT[i] = 
    \begin{cases}
    0 & \text{if } i == 0\\
    max(l_i, h_i) & \text{if } i == 1\\
    max(OPT[i-1] + l_i, OPT[i-2] + h_i) & \text{otherwise}\\
    \end{cases}
\end{equation}

    \begin{algorithm}
    \caption{Find the OPT}\label{alg:cap}
    \begin{algorithmic}    
    \State $OPT[0] = 0$
    \For{$i = 0$ to n}
    \If{$i$ == 1}
        \State $OPT[i] = max(l_i, h_i)$
    \ElsIf{$i >$ 1}
        \State $OPT[i] = max(l_i + OPT[i-1], h_i + OPT[i-2])$
    \EndIf
    \EndFor
    \State return OPT[n]
    \end{algorithmic}
    \end{algorithm}
    \textbf{Proof Of Correctness:} There are three cases for the OPT if we consider the weeks, 
    \begin{enumerate}
        \item First if we have 0 weeks, there wont be any time to work. Therefore, we know that OPT[0] = 0. 
        \item Then, if we have the first week, we can just compare the low and highest job and then take the maximum for both.
        \item For every other iterative week, there are two different scenarios, we can take a high stress job which will take 2 weeks and a low stress job which will compare to the high stress job (2 weeks). Therefore, we find the maximum profit we earn from a job given that for both jobs at the last interval for a low stress job and the last 2nd interval (since we need to rest for 1 week) for a high stress job.
    \end{enumerate}
    \textbf{Runtime:} We iterate through the loop from i = 0 to n once to find the OPT answer, thus the runtime is O(n)
    \item You are given positive integers $x_1, x_2, ..., x_n$. You goal is to divide these numbers into two disjoint sets A and B so that $A \cup B$ includes all these numbers, and so that the total sum of numbers in B is exactly five times as much as the total sum of numbers in A. \\
    \textbf{Subproblem:} OPT[i, z] = a boolean value which equals True exactly when it is possible to select a subset of numbers using only $x_1, ..., x_i$, which adds up exactly $z$.

    \begin{algorithm}
    \caption{Find the OPT}\label{alg:cap}
    \begin{algorithmic}    
    \State $\forall z, OPT[0, z] = False$
    \State $\forall i, OPT[i, 0] = True$
    \For{$i = 1$ to n}
        \For{$z = 1$ to X}
    \If{$OPT[i-1, z] == true$ or $L[i-1, z-x_i == true]$}
        \State $OPT[i, z] = true$
    \Else
        \State $OPT[i, z] = false$
    \EndIf
    \EndFor
    \EndFor
    \If{$OPT[n, X/6] == true$ and $L[n, 5X/6] == true$}
        \State return true
    \Else
        \State return false
    \EndIf
    \State return OPT[n]
    \end{algorithmic}
    \end{algorithm}
    \textbf{Proof Of Correctness:} There are three cases for the OPT if we consider the weeks, 
    \begin{enumerate}
        \item We will either choose to use $x_i$ or not use which is the recurrence. Then the recurrence will shift by i, which then determines the optimal if we shift z by $x_i$. Both cases still produce z. In the end we return due to $OPT[n, X/6] == true$ since we need to consider all n items and $X/6$ (B exist) splits into $5X/6$ (A exists) from a distributed set.
    \end{enumerate}
    \textbf{Runtime:} We iterate through the loop from i = 0 to n and for every z until X. O(nX).
    
\end{enumerate}

\clearpage
\section{Max-Flow Algorithm}
\textbf{Max-Flow $\leftarrow\rightarrow$ Min-Cut} \\
A flow in the network needs to contain:
\begin{itemize}
    \item A directed graph G = (V, E) 
    \item All edges in the graph must contain a capacity
    \item There must only exist one source node (s) and one sink node (t)
\end{itemize}
Given a flow network (directed graph G = (V, E), capacities c(e) $\geq 0 \forall e \in $E, source node S, and sink node t. Goal: find max-flow, min-cut from s to t.

\subsection{Circulation}
Given a directed graph G = (V, E), capacities c(e) $\geq 0$, $\forall e \in$ E and demand $d_v \forall v \in V$. Then S = nodes where $d_v < 0$, T = nodes where $d_v > 0$. Goal: does there exist a feasible circulation.
\clearpage
\section{NP Completeness}
\subsection{NP Problems}
\begin{tabular}{|c|p{4cm}|p{9cm}|}
    \hline
    \textbf{NP-C Problem} & \textbf{Problem Type} & \textbf{Problem Description}\\
    \hline
    Vertex Cover & Covering problem & 
    \textbf{Given}: Undirected Graph $G$ and $k \geq 0$. 
    
    \textbf{Goal}: Does there exist a vertex cover (a set of nodes $S$, s.t. for all edges $(u,v)$ either $u \in S$ or $v \in S$ or both) of size $\leq k$?\\
    \hline
    Set Cover & Covering problem & 
    \textbf{Given}: Set $u$ of elements, and set $S_1, S_2, ..., S_m \subseteq u$ and $k \geq 0$. 
    
    \textbf{Goal}: Does there exist a collection of $\leq k$ sets that cover $u$ (the union contains $u$)?\\
    \hline
    Independent Set & Packing problem & 
    \textbf{Given}: Undirected graph $G$ and $k \geq 0$.
    
    \textbf{Goal}: Does there exists a independent set (a set of nodes $S$, s.t. for all $u,v \in S$, no edge $(u,v)$) if size $\leq k$?\\
    \hline
    Hamiltonian Cycle & Sequencing problem & 
    \textbf{Given}: Undirected or directed graph $G$.
    
    \textbf{Goal}: Does there exists a Hamiltonian cycles (uses all nodes exactly once)? \\
    \hline
    3-Color & Partitioning problem & 
    \textbf{Given}: Undirected graph $G$.
    
    \textbf{Goal}: Does there exists a way to color the nodes so that no two adjacent nodes are the same color? \\
    \hline
    k-Color & Partitioning problem & 
    \textbf{Given}: Undirected graph $G$ and $k \geq 0$.
    
    \textbf{Goal}: Does there exists a way to color the nodes where we only use k colors (no two adjacent nodes can have the same color)? \\
    \hline
    Traveling Sales Person & Sequencing problem & 
    \textbf{Given}: $n$ cities, $D \geq 0$, and distances $d(u,v)$ for all cities $u$ and $v$.
    
    \textbf{Goal}: Does there exists a tour (visits each city once) of length $\leq D$?\\
    
    \hline
    Subset Sum & Numerical problems &
    \textbf{Given}: $w_1, w_2, ..., w_n$ and $W$.
    
    \textbf{Goal}: Does there exist a subset that adds up to $W$?\\
    \hline
    Knapsack & Numerical problem &
    \textbf{Given}: $w_1, w_2, ..., w_n$, $W$, $v_1, v_2, ..., v_n$ and $V$.
    
    \textbf{Goal}: Does there exists a subset $S$ s.t. $\sum_{i \in S}w_i \leq W$ and $\sum_{i \in S}v_i \geq V$?\\
    \hline
    3-SAT & Satisfaction problems &
    \textbf{Given}: Variables $x_1, x_2, ..., x_n$ and clauses $(x_i\lor x_j \lor \bar{x}_k)$.
    
    \textbf{Goal}: $c_1 \cup c_2 \cup ... \cup c_n$ = T? (All of clauses are satisfiable)\\
    \hline
\end{tabular}
\subsection{NPC technique}
Given problem Y with y inputs.
\begin{enumerate}
    \item State that problem is in NP, the problem is in NP if a possible solution is verifiable in polynomial time.
    \item Show that Y is NP-Hard, by picking a known problem. General Method: Pick a NP-C problem that is reduces to the problem as problem X with x inputs (i.e. if we are solving for ZWCP then we can use Ham Path $\leq_p$ ZWCP). This means we are using ZWCP to solve for a case of hamiltonian path.
    \begin{itemize}
        \item Input: x, convert x inputs to y inputs, then solve for y and get an output (true or false $\rightarrow$ due to decision problem), convert true/false from y to x.
    \end{itemize}
    \item Then prove that iff the result of problem X is true then the result of problem Y is true as well
\end{enumerate}
\subsection{NP examples}
\begin{enumerate}
    \item You are given a list of $n$ students, their relationships (i.e. which students are friends, which are enemies, and which are neither), and $m$ vans with $c$ capacity for each van. Does there exist a way to assign all students to vans so that no van is overloaded and friends are assigned to the same van while enemies are separate? This is the Happy Road Trip Problem (HRTP)
    \begin{itemize}
        \item This problem is in NP, given a solution, we can verify this solution in polynomial time by checking all the vans to see if each student are not enemies in each van. This check is just an iteration through every student and looking and looking at each other student in the van to see if they are enemies.
        \item Independent Set $\leq_p$ HRTP.
        \item Given an undirected graph, G = (V,E) and $k \geq 0$. For each node V, we create a student $S_V$. Next, we set all the student's relationship as enemies. Then for each edge incident of every node V, we replace the enemy relationship as a friend relationship between the student $S_V$ and the endpoint of the edge as $S_E$. Then, we set m = k and c = $\infty$. Finally, we give all set inputs to HRTP, if HRTP returns true then there is an independent set of size k, otherwise there isn't.
        \item We are able to map the result of HRTP to independent set due to \\the result of HRTP $\leftarrow\rightarrow$ result of independent set (Proof:)\\
        ($\rightarrow$): for every student that are friends should be in the same van, and those who are enemies shouldn't. If we consider a student as a node, then a connection between them as friends and no connection as enemies, then all friends are independent of the enemies. \\
        ($\leftarrow$): for all nodes in an independent set, if two nodes are connected then both nodes select one as an independent set, if the two nodes are disconnected, then we have two separate independent sets. We can label this for the students, as there can be 1 van for two students (friends), which are nodes, and 2 vans for two enemies.
    \end{itemize}
    \item You are given a directed graph, G = (V, E), a list of $l$ paths $P_1, P_2, ..., P_l$ in this graph, and numbers $k \geq 0$ and $C \geq 0$. Does there exist a set S of paths from the list of $l$ paths so that $|S| \geq k$ and so that for every node, at most $C$ paths from this set $S$ pass through this node? In other words, do there exist $k$ paths so that if every node has a capacity of C, then we can use all $k$ of these paths simultaneously without violating the capacities? This is the Capacitated Path Problem (CPP). 
    \begin{itemize}
        \item This problem is in NP, given a solution, we can verify this solution in polynomial time by iterating through each path, and counting the total number of times a node is traversed in that node. Then we can easily determine if a capacity of a node is violated by checking the total number of times a node has been traversed.
        \item Independent Set $\leq_p$ CPP
        \item Given an undirected graph, G = (V, E) and $k \geq 0$. Create a directed graph G' = (V', E'), set every V' to V, and for each E create a directed edge from the incident nodes of E as each edge (i.e. A $-$ B is A $\leftarrow\rightarrow$ B). Next, create paths $P_i$ for every edge in G' in list $l$. Set k = k, C = 1. If the CPP returns true, then there is an independent set of size k, otherwise there isn't.
        \item Proof isn't included.
    \end{itemize}
    \item You are given a directed graph G = (V, E) with weights we on its edges e $\in$ E. The weights can be negative or positive. The Zero-Weight-Cycle Problem is to decide if there is a simple cycle in G so that the sum of the edge weights on this cycle is exactly 0. Prove that this problem is NP-complete.
    \begin{itemize}
        \item The Zero Weight Cycle Problem (ZWCP) is in NP, given a solution, we can check that the cycle has a sum of all the weights equal to 0. This can be done in polynomial time, since we are just going through the cycle and checking that it sums to 0.
        \item We can show that ZWCP is NP-Hard if Hamiltonian Path $\leq$\textsubscript{p} ZWCP
        \item Given an instance of Hamiltonian Path, with input G(V, E) with starting node s and ending node t. We create a new copied graph from G, G', that can support weights. For each edge in G', we set the weight to 1. Then we create an edge from t to s with an edge weight of (1 - number of nodes in G') (i.e. if there are 5 nodes, the weight will be -4). Then we return true if there is a zero weight cycle, false otherwise. Then it is trivial to check that there is a hamiltonian path is the result is true (then there is a path that exists), otherwise this path does not exist.
        \item Ham Path result ($\leftarrow\rightarrow$) ZWCP result\\
        ($\rightarrow$): since we have to travel all the nodes for a Hamiltonian path, the total weight of those edges traveled if all the edges are 1 will be the total number of nodes - 1 (since we start at one node). Then the last edge that will form a cycle is from t to s. Since we are checking if there is a simple cycle, this will guarantee that the cycle will include that edge and that having the weight being (number of nodes - 1) will equate to a zero weight cycle sum.\\
        ($\leftarrow$): we know that there exists a path that has a sum of zero weights, since we need to travel through all the edges, there cannot be a cycle in the hamiltonian path. However, by adding an edge from t to s, which are the edges unvisited by the path, we create a cycle, and that is the only cycle that we can visit for the zero weight cycle problem. This cycle of course, determines that there are zero weights overall, which then will mean that every node will be visited if the ZWCP is true, otherwise false.
    \end{itemize}
\end{enumerate}
\end{document}  